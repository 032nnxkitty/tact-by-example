var A=Object.defineProperty;var w=(s,e,t)=>e in s?A(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var l=(s,e,t)=>(w(s,typeof e!="symbol"?e+"":e,t),t);import{S as p,i as h,s as f,I as b,ac as y}from"../chunks/index.9fe14626.js";import{d as r,g,s as d}from"../chunks/store.d3ab02ad.js";import{d as C}from"../chunks/index.78404594.js";const I=`# Hello World

This is probably the simplest possible Tact program. It will provide callers with the classic output "hello world".

Tact lets you write smart contracts. This code defines a single contract named \`HelloWorld\`. Smart contracts must be deployed to the blockchain network to be usable, try to deploy this contract by pressing the <span class="mdButton blue">Deploy</span> button.

Contract deployments usually cost gas. This website deploys to an [emulator](https://github.com/tact-lang/tact-emulator) of TON blockchain, so gas is emulated TON coin (which is free).

If you're unfamilar with terms like *contract*, *deployment* and *gas*, please [read this post](https://blog.ton.org/what_is_blockchain) first. It's a great introduction to all blockchain terminology you will need to learn Tact.

## A simple interaction

Contracts can have *getters* like \`greeting()\`. Getters are special external interface functions that allow users to query information from the contract. Try to call the getter by pressing the <span class="mdButton teal">Get greeting</span> button. Calling getters is free and does not cost gas.

Don't worry if some things aren't clear now, we will dive into getters in more detail later.`,v=`contract HelloWorld {

    get fun greeting(): String {
        return "hello world";
    }

}`;async function u(){const s=r.Cell.fromBase64("te6ccgECDgEAAW8AART/APSkE/S88sgLAQIBYgIDAo7QAdDTAwFxsKMB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiFRQUwNvBPhhAvhi2zxZ2zwwMMj4QwHMfwHKAMntVAcEAgEgBQYAPnAh10nCH5UwINcLH94Cklt/4AHAAAHXScEhsJF/4HACD72NVtnm2eGMBwgCASAKCwE07UTQ1AH4Y9IAMJFt4Pgo1wsKgwm68uCJ2zwJABqLtoZWxsbyB3b3JsZIAAJtALm7vRgnBc7D1dLK57HoTsOdZKhRtmgnCd1jUtK2R8syLTry398WI5gnAgVcAbgGdjlM5YOq5HJbLDgnAb1J3vlUWW8cdT094FWcMmgnCdl05as07LczoOlm2UZuikgCAUgMDQARsK+7UTQ0gABgAHWybuNDVpcGZzOi8vUW1VcTQ3ZEpja2pYb3RQVENkdmhGNkdDeEZvcHBBNDE0QnRjS0Z5R3A0SENiR4IA=="),e=r.Cell.fromBase64("te6cckECEAEAAXkAAQHAAQEFoPYVAgEU/wD0pBP0vPLICwMCAWIMBAIBIAoFAgEgCQYCAUgIBwB1sm7jQ1aXBmczovL1FtVXE0N2RKY2tqWG90UFRDZHZoRjZHQ3hGb3BwQTQxNEJ0Y0tGeUdwNEhDYkeCAAEbCvu1E0NIAAYAC5u70YJwXOw9XSyuex6E7DnWSoUbZoJwndY1LStkfLMi068t/fFiOYJwIFXAG4BnY5TOWDquRyWyw4JwG9Sd75VFlvHHU9PeBVnDJoJwnZdOWrNOy3M6DpZtlGbopIAg+9jVbZ5tnhjA4LABqLtoZWxsbyB3b3JsZIAo7QAdDTAwFxsKMB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiFRQUwNvBPhhAvhi2zxZ2zwwMMj4QwHMfwHKAMntVA4NAD5wIddJwh+VMCDXCx/eApJbf+ABwAAB10nBIbCRf+BwATTtRNDUAfhj0gAwkW3g+CjXCwqDCbry4InbPA8AAm17HG9k");let t=r.beginCell();t.storeRef(e),t.storeUint(0,1);const n=t.endCell();return{code:s,data:n}}const B={2:{message:"Stack undeflow"},3:{message:"Stack overflow"},4:{message:"Integer overflow"},5:{message:"Integer out of expected range"},6:{message:"Invalid opcode"},7:{message:"Type check error"},8:{message:"Cell overflow"},9:{message:"Cell underflow"},10:{message:"Dictionary error"},13:{message:"Out of gas error"},32:{message:"Method ID not found"},34:{message:"Action is invalid or not supported"},37:{message:"Not enough TON"},38:{message:"Not enough extra-currencies"},128:{message:"Null reference exception"},129:{message:"Invalid serialization prefix"},130:{message:"Invalid incoming message"},131:{message:"Constraints error"},132:{message:"Access denied"},133:{message:"Contract stopped"},134:{message:"Invalid argument"},135:{message:"Code of a contract was not found"},136:{message:"Invalid address"},137:{message:"Masterchain support is not enabled for this contract"}};class i{constructor(e,t){l(this,"address");l(this,"init");l(this,"abi",{types:[{name:"StateInit",header:null,fields:[]},{name:"Context",header:null,fields:[]},{name:"SendParameters",header:null,fields:[]}],errors:B});this.address=e,this.init=t}static async init(){return await u()}static async fromInit(){const e=await u(),t=r.contractAddress(0,e);return new i(t,e)}static fromAddress(e){return new i(e)}async send(e,t,n,a){let o=null;if(a===null&&(o=new r.Cell),o===null)throw new Error("Invalid message type");await e.internal(t,{...n,body:o})}async getGreeting(e){let t=new r.TupleBuilder;return(await e.get("greeting",t.build())).stack.readString()}}function D(s,e,t){let n;b(s,d,o=>t(2,n=o));let a;return y(d,n={markdown:I,tactCode:v,deploy:async()=>{const o=await C.Blockchain.create(),c=await o.treasury("deployer");c.getSender(),a=o.openContract(await i.fromInit());const m={[c.address.toString()]:"deployer",[a.address.toString()]:"contract"};return[[a],m,[await a.send(c.getSender(),{value:r.toNano(1)},null)]]},messages:{},getters:{greeting:async()=>await a.getGreeting()},prev:g(import.meta.url).prev,next:g(import.meta.url).next},n),[]}class N extends p{constructor(e){super(),h(this,e,D,null,f,{})}}export{N as default};
