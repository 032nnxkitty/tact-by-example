var y=Object.defineProperty;var m=(s,e,t)=>e in s?y(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var c=(s,e,t)=>(m(s,typeof e!="symbol"?e+"":e,t),t);import{S as w,i as p,s as C,I as f,ac as B}from"../../../../chunks/index-1d4083c1.js";import{d as a,s as g}from"../../../../chunks/store-ab11a47e.js";import{d as I,g as u}from"../../../../chunks/helpers-be3eeda0.js";const h="# The Deployable Trait\n\nTact doesn't support classical class inheritance, but contracts can implement *traits*. One of the commonly used traits is `Deployable`. It implements a simple receiver for the `Deploy` message which helps deploy contracts in a standard way.\n\nAll contracts are deployed by sending them a message. This can be any message, but best practice is to designate the special `Deploy` message for this purpose.\n\nThis message has a single field, `queryId`, which is provided by the deployer. If the deploy succeeds, the contract will reply with the message `DeployOk` and echo the same `queryId` in the response.\n\nIf you're using TypeScript to deploy, sending the deploy message should look like:\n\n```ts\nconst msg = { $$type: \"Deploy\", queryId: 0n };\n await contract.send(sender, { value: toNano(1) }, msg);\n```\n",b=`// this trait has to be imported
import "@stdlib/deploy";

// the Deployable trait adds a default receiver for the "Deploy" message
contract Counter with Deployable {
 
    val: Int as uint32;
 
    init() {
        self.val = 0;
    }
 
    receive("increment") {
        self.val = self.val + 1;
    }
 
    get fun value(): Int {
        return self.val;
    }
}`;function v(s){return e=>{let t=e;t.storeUint(2490013878,32),t.storeUint(s.queryId,64)}}async function d(){const s=a.Cell.fromBase64("te6ccgECCwEAAlsAART/APSkE/S88sgLAQIBYgIDAt7QAdDTAwFxsMABkX+RcOIB+kABINdJgQELuvLgiCDXCwoggwm6IYEE/7qx8uCIgwm68uCJIkFVbwT4Ye1E0NQB+GLSAAGU0x8BMY6OMPgo1wsKgwm68uCJ2zziWds8MMj4QgHMfwHKAAEByx/J7VQKBAIBWAgJAfDtou37cCHXScIflTAg1wsf3gKSW3/gIYIQlGqYtrqOozHTHwGCEJRqmLa68uCB0z8BMcgBghCv+Q9XWMsfyz/J2zx/4AHAAI4r+QGC8MT41yMS7f3vW3vseDO9uxYtFRG9eKkSrtDyY3r2VXKuupSkf9sx4JEw4nAFASb4QW8kECNfA39wUAOAQgFtbds8BgHOyHEBygFQBwHKAHABygJQBSDXSYEBC7ry4Igg1wsKIIMJuiGBBP+6sfLgiIMJuvLgic8WUAP6AnABymgjbrMlbrOxlzMzAXABygDjDSFus5x/AcoAASBu8tCAAcyVMXABygDiyQH7AAcAmH8BygDIcAHKAHABygAkbrOdfwHKAAQgbvLQgFAEzJY0A3ABygDiJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4nABygACfwHKAALJWMwAubu9GCcFzsPV0srnsehOw51kqFG2aCcJ3WNS0rZHyzItOvLf3xYjmCcCBVwBuAZ2OUzlg6rkclssOCcBvUne+VRZbxx1PT3gVZwyaCcJ2XTlqzTstzOg6WbZRm6KSAFFuawO1E0NQB+GLSAAGU0x8BMY6OMPgo1wsKgwm68uCJ2zzigKAAJw"),e=a.Cell.fromBase64("te6cckECDQEAAmUAAQHAAQEFoendAgEU/wD0pBP0vPLICwMCAWIHBAIBWAYFAUW5rA7UTQ1AH4YtIAAZTTHwExjo4w+CjXCwqDCbry4InbPOKAwAubu9GCcFzsPV0srnsehOw51kqFG2aCcJ3WNS0rZHyzItOvLf3xYjmCcCBVwBuAZ2OUzlg6rkclssOCcBvUne+VRZbxx1PT3gVZwyaCcJ2XTlqzTstzOg6WbZRm6KSALe0AHQ0wMBcbDAAZF/kXDiAfpAASDXSYEBC7ry4Igg1wsKIIMJuiGBBP+6sfLgiIMJuvLgiSJBVW8E+GHtRNDUAfhi0gABlNMfATGOjjD4KNcLCoMJuvLgids84lnbPDDI+EIBzH8BygABAcsfye1UDAgB8O2i7ftwIddJwh+VMCDXCx/eApJbf+AhghCUapi2uo6jMdMfAYIQlGqYtrry4IHTPwExyAGCEK/5D1dYyx/LP8nbPH/gAcAAjiv5AYLwxPjXIxLt/e9be+x4M727Fi0VEb14qRKu0PJjevZVcq66lKR/2zHgkTDicAkBJvhBbyQQI18Df3BQA4BCAW1t2zwKAc7IcQHKAVAHAcoAcAHKAlAFINdJgQELuvLgiCDXCwoggwm6IYEE/7qx8uCIgwm68uCJzxZQA/oCcAHKaCNusyVus7GXMzMBcAHKAOMNIW6znH8BygABIG7y0IABzJUxcAHKAOLJAfsACwCYfwHKAMhwAcoAcAHKACRus51/AcoABCBu8tCAUATMljQDcAHKAOIkbrOdfwHKAAQgbvLQgFAEzJY0A3ABygDicAHKAAJ/AcoAAslYzAACcNjsCho=");let t=a.beginCell();t.storeRef(e),t.storeUint(0,1);const o=t.endCell();return{code:s,data:o}}const D={2:{message:"Stack undeflow"},3:{message:"Stack overflow"},4:{message:"Integer overflow"},5:{message:"Integer out of expected range"},6:{message:"Invalid opcode"},7:{message:"Type check error"},8:{message:"Cell overflow"},9:{message:"Cell underflow"},10:{message:"Dictionary error"},13:{message:"Out of gas error"},32:{message:"Method ID not found"},34:{message:"Action is invalid or not supported"},37:{message:"Not enough TON"},38:{message:"Not enough extra-currencies"},128:{message:"Null reference exception"},129:{message:"Invalid serialization prefix"},130:{message:"Invalid incoming message"},131:{message:"Constraints error"},132:{message:"Access denied"},133:{message:"Contract stopped"},134:{message:"Invalid argument"},135:{message:"Code of a contract was not found"},136:{message:"Invalid address"},137:{message:"Masterchain support is not enabled for this contract"}};class A{constructor(e,t){c(this,"address");c(this,"init");c(this,"abi",{errors:D});this.address=e,this.init=t}static async init(){return await d()}static async fromInit(){const e=await d(),t=a.contractAddress(0,e);return new A(t,e)}static fromAddress(e){return new A(e)}async send(e,t,o,n){let r=null;if(n==="increment"&&(r=a.beginCell().storeUint(0,32).storeStringTail(n).endCell()),n&&typeof n=="object"&&!(n instanceof a.Slice)&&n.$$type==="Deploy"&&(r=a.beginCell().store(v(n)).endCell()),r===null)throw new Error("Invalid message type");await e.internal(t,{...o,body:r})}async getValue(e){let t=new a.TupleBuilder;return(await e.get("value",t.build())).stack.readBigNumber()}}function H(s,e,t){let o;f(s,g,i=>t(2,o=i));let n,r;return B(g,o={markdown:h,tactCode:b,deploy:async()=>{const i=await I.Blockchain.create(),l=await i.treasury("deployer");return n=l.getSender(),r=i.openContract(await A.fromInit()),[await r.send(l.getSender(),{value:a.toNano(1)},{$$type:"Deploy",queryId:0n})]},messages:{increment:async()=>[await r.send(n,{value:a.toNano(1)},"increment")]},getters:{value:async()=>await r.getValue()},prev:u(import.meta.url).prev,next:u(import.meta.url).next},o),[]}class Q extends w{constructor(e){super(),p(this,e,H,null,C,{})}}export{Q as default};
