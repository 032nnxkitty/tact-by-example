import{S as y,i as u,s as m,J as p,ad as f}from"../../../chunks/index-a89a8bfe.js";import{d as n,s as c}from"../../../chunks/store-04c80bb0.js";import{d as w}from"../../../chunks/index-e79fdc6e.js";import{g}from"../../../chunks/helpers-07666f35.js";const B="# The Deployable Trait\n\nTact doesn't support classical class inheritance, but contracts can implement _traits_. One of the commonly used traits is `Deployable`. It implements a useful receiver for a `Deploy` message which helps deploy contracts in a unified way.\n\nAll contracts are deployed by sending them a message. This can be any message, but best practice is to designate a special `Deploy` message to make this explicit.\n\nThis message has a single field, `queryId`, which is provided by the deployer. If the deploy succeeds, the contract will reply with the message `DeployOk` and echo the same `queryId` in the response.\n\nIf you're using TypeScript to deploy, sending the deploy message should look something like:\n\n```ts\nconst msg = { $$type: \"Deploy\", queryId: 0n };\nawait contract.send(sender, { value: toNano(1) }, msg);\n```\n",I=`// this trait has to be imported
import "@stdlib/deploy";

// the Deployable trait adds a default receiver for the "Deploy" message
contract Counter with Deployable {
 
    val: Int as uint32;
 
    init() {
        self.val = 0;
    }
 
    receive("increment") {
        self.val = self.val + 1;
    }
 
    get fun value(): Int {
        return self.val;
    }
}`;function h(a){return e=>{let t=e;t.storeUint(2490013878,32),t.storeUint(a.queryId,64)}}async function d(){const a=n.Cell.fromBase64("te6ccgECCwEAAfEAART/APSkE/S88sgLAQIBYgIDAoTQAdDTAwFxsMABkX+RcOIB+kAiUFVvBPhh7UTQ1AH4YtIAAZTTHwExjoMw2zziWds8MMj4QgHMfwHKAAEByx/J7VQKBAIBWAgJAfDtou37cCHXScIflTAg1wsf3gKSW3/gIYIQlGqYtrqOozHTHwGCEJRqmLa68uCB0z8BMcgBghCv+Q9XWMsfyz/J2zx/4AHAAI4r+QGC8MT41yMS7f3vW3vseDO9uxYtFRG9eKkSrtDyY3r2VXKuupSkf9sx4JEw4nAFASb4QW8kECNfA39wUAOAQgFtbds8BgH2yHEBygFQBwHKAHABygJQBc8WUAP6AnABymgjbrMlbrOxjkx/AcoAyHABygBwAcoAJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4iRus51/AcoABCBu8tCAUATMljQDcAHKAOJwAcoAAn8BygACyVjMlzMzAXABygDiIW6zBwAwnH8BygABIG7y0IABzJUxcAHKAOLJAfsAAJW7vRgnBc7D1dLK57HoTsOdZKhRtmgnCd1jUtK2R8syLTry398WI5gnAgVcAbgGdjlM5YOq5HJbLDgnAb1J3vlUWW8cdT094FWcMmgBL7msDtRNDUAfhi0gABlNMfATGOgzDbPOKAoAAnA="),e=n.Cell.fromBase64("te6cckECDQEAAfsAAQHAAQEFoendAgEU/wD0pBP0vPLICwMCAWIHBAIBWAYFAS+5rA7UTQ1AH4YtIAAZTTHwExjoMw2zzigMAJW7vRgnBc7D1dLK57HoTsOdZKhRtmgnCd1jUtK2R8syLTry398WI5gnAgVcAbgGdjlM5YOq5HJbLDgnAb1J3vlUWW8cdT094FWcMmgChNAB0NMDAXGwwAGRf5Fw4gH6QCJQVW8E+GHtRNDUAfhi0gABlNMfATGOgzDbPOJZ2zwwyPhCAcx/AcoAAQHLH8ntVAwIAfDtou37cCHXScIflTAg1wsf3gKSW3/gIYIQlGqYtrqOozHTHwGCEJRqmLa68uCB0z8BMcgBghCv+Q9XWMsfyz/J2zx/4AHAAI4r+QGC8MT41yMS7f3vW3vseDO9uxYtFRG9eKkSrtDyY3r2VXKuupSkf9sx4JEw4nAJASb4QW8kECNfA39wUAOAQgFtbds8CgH2yHEBygFQBwHKAHABygJQBc8WUAP6AnABymgjbrMlbrOxjkx/AcoAyHABygBwAcoAJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4iRus51/AcoABCBu8tCAUATMljQDcAHKAOJwAcoAAn8BygACyVjMlzMzAXABygDiIW6zCwAwnH8BygABIG7y0IABzJUxcAHKAOLJAfsAAAJwyrXsNg==");let t=n.beginCell();t.storeRef(e),t.storeUint(0,1);const r=t.endCell();return{code:a,data:r}}const C={2:{message:"Stack undeflow"},3:{message:"Stack overflow"},4:{message:"Integer overflow"},5:{message:"Integer out of expected range"},6:{message:"Invalid opcode"},7:{message:"Type check error"},8:{message:"Cell overflow"},9:{message:"Cell underflow"},10:{message:"Dictionary error"},13:{message:"Out of gas error"},32:{message:"Method ID not found"},34:{message:"Action is invalid or not supported"},37:{message:"Not enough TON"},38:{message:"Not enough extra-currencies"},128:{message:"Null reference exception"},129:{message:"Invalid serialization prefix"},130:{message:"Invalid incoming message"},131:{message:"Constraints error"},132:{message:"Access denied"},133:{message:"Contract stopped"},134:{message:"Invalid argument"},135:{message:"Code of a contract was not found"},136:{message:"Invalid address"}};class A{constructor(e,t){this.abi={errors:C},this.address=e,this.init=t}static async init(){return await d()}static async fromInit(){const e=await d(),t=n.contractAddress(0,e);return new A(t,e)}static fromAddress(e){return new A(e)}async send(e,t,r,s){let o=null;if(s==="increment"&&(o=n.beginCell().storeUint(0,32).storeStringTail(s).endCell()),s&&typeof s=="object"&&!(s instanceof n.Slice)&&s.$$type==="Deploy"&&(o=n.beginCell().store(h(s)).endCell()),o===null)throw new Error("Invalid message type");await e.internal(t,{...r,body:o})}async getValue(e){let t=new n.TupleBuilder;return(await e.get("value",t.build())).stack.readBigNumber()}}function b(a,e,t){let r;p(a,c,l=>t(2,r=l));let s,o;return f(c,r={markdown:B,tactCode:I,deploy:async()=>{const l=await w.Blockchain.create(),i=await l.treasury("deployer");return s=i.getSender(),o=l.openContract(await A.fromInit()),[await o.send(i.getSender(),{value:n.toNano(1)},{$$type:"Deploy",queryId:0n})]},messages:{increment:async()=>[await o.send(s,{value:n.toNano(1)},"increment")]},getters:{value:async()=>await o.getValue()},prev:g(import.meta.url).prev,next:g(import.meta.url).next},r),[]}class M extends y{constructor(e){super(),u(this,e,b,null,m,{})}}export{M as default};
